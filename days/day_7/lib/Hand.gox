package lib

import (
	"fmt"
	"log"
)

type Suit uint16

const (
	Club    Suit = 0x8000
	Diamond      = 0x4000
	Heart        = 0x2000
	Spade        = 0x1000
)

type Rank uint16

const (
	Deuce Rank = iota
	Trey
	Four
	Five
	Six
	Seven
	Eight
	Nine
	Ten
	Jack
	Queen
	King
	Ace
)

type Card int32

func NewCard(s Suit, r Rank) Card {
	if int(r) >= len(Primes) {
		log.Panicf("unknown rank: %d", r)
	}

	return Card(Primes[r] | (int(r) << 8) | int(s) | (1 << uint(16+r)))
}

func (c Card) Suit() Suit {
	return Suit(c & 0xf000)
}

func (c Card) Rank() Rank {
	return Rank((c >> 8) & 0x0f)
}

func (c Card) Prime() int {
	return int(c) & 0xff
}

func (c Card) Bit() int {
	return int(c) >> 16
}

type Hand interface {
	Eval() Score
	SetCard(int, Card)
	Card(int) Card
	Len() int
	Cards() []Card
	Prime() int
	Bit() int
}

func NewHand(n int) Hand {
	switch n {
	case 5:
		return NewFiveCardHand()
	default:
		panic(fmt.Errorf("hand of %d cards not supported", n))
	}
}

type FiveCardHand struct {
	A, B, C, D, E, F Card
}

func NewFiveCardHand() *FiveCardHand { return new(FiveCardHand) }

// IsSuited returns true if entire hand is of the same Suit.
func (h *FiveCardHand) IsSuited() bool {
	return h.A&h.B&h.C&h.D&h.E&0xf000 != 0
}

func (h *FiveCardHand) Eval() Score {
	// Flushes and Straight Flushes
	if h.IsSuited() {
		return Flushes[h.Bit()]
	}

	// Straights and High Cards
	if s := Unique5[h.Bit()]; s != 0 {
		return s
	}

	// and others... [inlined `findit()`]
	var (
		k = int((h.A & 0xff) * (h.B & 0xff) * (h.C & 0xff) * (h.D & 0xff) * (h.E & 0xff))
	)
	for low, mid, high := 0, 4887>>1, 4887; ; mid = (high + low) >> 1 {
		if product := products[mid]; k < product {
			high = mid - 1
		} else if k > product {
			low = mid + 1
		} else {
			return values[mid]
		}
	}
}

func (h *FiveCardHand) SetCard(n int, c Card) {
	switch n {
	case 0:
		h.A = c
	case 1:
		h.B = c
	case 2:
		h.C = c
	case 3:
		h.D = c
	case 4:
		h.E = c
	default:
		log.Panicf("index overflow: %d", n)
	}
}

func (h *FiveCardHand) Card(n int) Card {
	switch n {
	case 0:
		return h.A
	case 1:
		return h.B
	case 2:
		return h.C
	case 3:
		return h.D
	case 4:
		return h.E
	default:
		log.Panicf("index overflow: %d", n)
		return 0
	}
}

func (h FiveCardHand) Len() int { return 5 }

func (h *FiveCardHand) Cards() []Card {
	return []Card{h.A, h.B, h.C, h.D, h.E}
}

func (h *FiveCardHand) Prime() int {
	return int((h.A & 0xff) * (h.B & 0xff) * (h.C & 0xff) * (h.D & 0xff) * (h.E & 0xff))
}

func (h *FiveCardHand) Bit() int {
	return int(h.A|h.B|h.C|h.D|h.E) >> 16
}

func (h *FiveCardHand) String() string {
	return fmt.Sprintf("[%v %v %v %v %v]", h.A, h.B, h.C, h.D, h.E)
}

type hand []Card

func (h hand) SetCard(n int, c Card) { h[n] = c }

func (h hand) Card(n int) Card { return h[n] }

func (h hand) Len() int { return len(h) }

func (h hand) Cards() []Card { return h }

// Product of each Card's Prime
func (h hand) Prime() int {
	product := 1

	for _, c := range h {
		product *= c.Prime()
	}

	return product
}

func (h hand) Bit() int {
	var bit int

	for _, c := range h {
		bit |= c.Bit()
	}

	return bit
}

type Score int16

func (s Score) Less(other Score) bool {
	// CactusKevScore goes from 9999 towards zero, where 9999 is the lowest values
	return s > other
}

func (s Score) Category() Category {
	switch {
	case s > 6185:
		return HighCard

	case s > 3325:
		return OnePair

	case s > 2467:
		return TwoPair

	case s > 1609:
		return ThreeOfAKind

	case s > 1599:
		return Straight

	case s > 322:
		return Flush

	case s > 166:
		return FullHouse

	case s > 10:
		return FourOfAKind

	default:
		return StraightFlush
	}
}

func (s Score) String() string {
	return fmt.Sprintf("%v(%d)", s.Category(), s)
}

type Category int

const (
	StraightFlush Category = iota
	FourOfAKind
	FullHouse
	Flush
	Straight
	ThreeOfAKind
	TwoPair
	OnePair
	HighCard
)

func (c Category) String() string {
	switch c {
	case StraightFlush:
		return "Straight Flush"
	case FourOfAKind:
		return "Four of a Kind"
	case FullHouse:
		return "Full House"
	case Flush:
		return "Flush"
	case Straight:
		return "Straight"
	case ThreeOfAKind:
		return "Three of a Kind"
	case TwoPair:
		return "Two Pair"
	case OnePair:
		return "One Pair"
	case HighCard:
		return "High Card"
	default:
		log.Panicf("unknown Category %d", c)
	}

	return ""
}
